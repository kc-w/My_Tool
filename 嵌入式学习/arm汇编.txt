Cortex-A 芯片一上电 SP 指针还没初始化 环境还没准备好，所以肯定不能运行 C 代码，必须先用汇编语言设置好 C 环境，
比如初始化 DDR、设置 SP 指针等等，当汇编把 C 环境设置好了以后才可以运行 C 代码，所以 Cortex-A 一开始肯定是汇编代码，
其实 STM32 也一样的，一开始也是汇编


<<ARM ArchitectureReference Manual ARMv7-A and ARMv7-R edition.pdf>>
<<ARM CortexA(armV7)编程手册 V4.0.pdf>>
第一份文档主要讲解 ARMv7-A 和 ARMv7-R 指令集的开发，Cortex-A7 使用的是 ARMv7-A 指令集，
第二份文档主要讲解 Cortex-A(armV7)编程的，这两份文档是学习 Cortex-A 不可或缺的文档



GNU 汇编语法
编写的是ARM汇编，编译使用的 GCC 交叉编译器，所以我们的汇编代码要符合 GNU 语法
GNU 汇编语法适用于所有的架构，并不是 ARM 独享的， GNU 汇编由一系列的语句组成，每行一条语句，每条语句有三个可选部分，如下：

label： instruction @ comment

label:
    即标号，表示地址位置，有些指令前面可能会有标号，这样就可以通过这个标号得到指令的地址，标号也可以用来表示数据地址。
    注意 label 后面的“：”，任何以“：”结尾的标识符都会被识别为一个标号。
instruction:
    即指令，也就是汇编指令或伪指令。
@comment :
    @符号，表示后面的是注释，就跟 C 语言里面的“/*”和“*/”一样，其实在 GNU 汇编文件中我们也可以使用“/*”和“*/”来注释。


GNU 汇编函数返回语句不是必须的，如下代码就是用汇编写的 Cortex-A7 中断服务函数：

    /* 未定义中断 */
    Undefined_Handler:
    ldr r0, =Undefined_Handler
    bx r0

    /* SVC 中断 */
    SVC_Handler:
    ldr r0, =SVC_Handler
    bx r0

    /* 预取终止中断 */
    PrefAbort_Handler:
    ldr r0, =PrefAbort_Handler
    bx r0

上述代码中定义了三个汇编函数： Undefined_Handler、 SVC_Handler 和PrefAbort_Handler。
以函数 Undefined_Handler 为例我们来看一下汇编函数组成，“Undefined_Handler”就是函数名，
“ldr r0, =Undefined_Handler”是函数体，“bx r0”是函数返回语句，“bx”指令是返回指令，函数返回语句不是必须的。

===================================处理器内部数据传输指令

使用处理器做的最多事情就是在处理器内部来回的传递数据，常见的操作有：
①、将数据从一个寄存器传递到另外一个寄存器。
②、将数据从一个寄存器传递到特殊寄存器，如 CPSR 和 SPSR 寄存器。
③、将立即数传递到寄存器。
数据传输常用的指令有三个： MOV、 MRS 和 MSR，这三个指令的用法如表 7.2.1.1 所示：
指令    目的      源       描述
MOV     R0        R1       将 R1 里面的数据复制到 R0 中。
MRS     R0        CPSR     将特殊寄存器 CPSR 里面的数据复制到 R0 中。
MSR     CPSR      R1       将 R1 里面的数据复制到特殊寄存器 CPSR 里中。


1、 MOV 指令
MOV 指令用于将数据从一个寄存器拷贝到另外一个寄存器，或者将一个立即数传递到寄存器里面，使用示例如下：
MOV R0, R1         @将寄存器 R1 中的数据传递给 R0，即 R0=R1
MOV R0, #0X12      @将立即数 0X12 传递给 R0 寄存器，即 R0=0X12

2、 MRS 指令
MRS 指令用于将特殊寄存器(如 CPSR 和 SPSR)中的数据传递给通用寄存器，要读取特殊寄存器的数据只能使用 MRS 指令！使用示例如下：
MRS R0, CPSR       @将特殊寄存器 CPSR 里面的数据传递给 R0，即 R0=CPSR

3、 MSR 指令
MSR 指令和 MRS 刚好相反， MSR 指令用来将普通寄存器的数据传递给特殊寄存器，写特殊寄存器只能使用 MSR，使用示例如下：
MSR CPSR, R0       @将 R0 中的数据复制到 CPSR 中，即 CPSR=R0



===================================存储器访问指令

ARM 不能直接访问存储器，比如 RAM 中的数据， I.MX6UL 中的寄存器就是 RAM 类型的，
我们用汇编来配置 I.MX6UL 寄存器的时候需要借助存储器访问指令，一般先将要配置的值
写入到 Rx(x=0~12)寄存器中，然后借助存储器访问指令将 Rx 中的数据写入到寄存器中。
读取 I.MX6UL 寄存器也是一样的，只是过程相反。
常用的存储器访问指令有两种： LDR 和 STR
指令                       描述
LDR Rd, [Rn , #offset]     从存储器 Rn+offset 的位置读取数据存放到 Rd 中。
STR Rd, [Rn, #offset]      将 Rd 中的数据写入到存储器中的 Rn+offset 位置。

1、 LDR 指令
LDR 主要用于从存储加载数据到寄存器 Rx 中， LDR 也可以将一个立即数加载到寄存器 Rx中， LDR 加载立即数的时候要使用“=”，而不是“#”。
在嵌入式开发中， LDR 最常用的就是读取 CPU 的寄存器值，比如有个寄存器 GPIO1_GDIR，其地址为 0X0209C004，现在要读取这个寄存器中的数据，
示例代码如下：

1 LDR R0, =0X0209C004    @将寄存器地址 0X0209C004 加载到 R0 中，即 R0=0X0209C004
2 LDR R1, [R0]           @读取地址 0X0209C004 中的数据到 R1 寄存器中

上述代码就是读取寄存器 GPIO1_GDIR 中的值，读取到的寄存器值保存在 R1 寄存器中，上面代码中 offset 是 0，也就是没有用到 offset


2、 STR 指令
LDR 是从存储器读取数据， STR 就是将数据写入到存储器中，同样以GPIO1_GDIR 为例，现在配置寄存器 GPIO1_GDIR 的值为 0X2000002，
示例代码如下：

1 LDR R0, =0X0209C004    @将寄存器地址 0X0209C004 加载到 R0 中，即 R0=0X0209C004
2 LDR R1, =0X20000002    @R1 保存要写入到寄存器的值，即 R1=0X20000002
3 STR R1, [R0]           @将 R1 中的值写入到 R0 中所保存的地址中

LDR 和 STR 都是按照字进行读取和写入的，也就是操作的 32 位数据，如果要按照字节、半字进行操作的话可以在指令“LDR”后面加上 B 或 H，
比如按字节操作的指令就是 LDRB 和STRB，按半字操作的指令就是 LDRH 和 STRH。


===================================压栈和出栈指令

通常会在 A 函数中调用 B 函数，当 B 函数执行完以后再回到 A 函数继续执行。
要想在跳回 A 函数以后代码能够接着正常运行，那就必须在跳到 B 函数之前将当前处理器状态保存起来(就是保存 R0-R15 这些寄存器值)，
当 B 函数执行完成后将保存在寄存器里的值恢复为R0-R15 ,保存 R0-R15 寄存器的操作就叫做现场保护，恢复 R0-R15 寄存器的操作就叫做恢复现场。
在进行现场保护的时候需要进行压栈(入栈)操作，恢复现场就要进行出栈操作。
压栈的指令为 PUSH，出栈的指令为 POP，是一种多存储和多加载指令，即可以一次操作多个寄存器数据，利用当前的栈指针 SP 来生成地址
PUSH 和 POP 的用法如下所示：

指令                描述
PUSH <reg list>     将寄存器列表存入栈中。
POP <reg list>      从栈中恢复寄存器列表。

假如现在要将 R0-R3 和 R12 这 5 个寄存器压栈，当前的 SP 指针指向 0X80000000，处理器的堆栈是向下增长的，使用的汇编代码如下：

PUSH {R0~R3, R12}     @将 R0~R3 和 R12 压栈(从右到左进行压栈)
PUSH {LR}             @将 LR 进行压栈
POP {LR}              @先恢复 LR
POP {R0~R3,R12}       @在恢复 R0~R3,R12(从左到右出栈)

PUSH 和 POP 的另外一种写法是"STMFD SP!"和"LDMFD SP!"，因此上面的汇编代码可以改为：

STMFD SP!,{R0~R3, R12}    @R0~R3,R12 入栈
STMFD SP!,{LR}            @LR 入栈
LDMFD SP!,{LR}           @先恢复 LR
LDMFD SP!,{R0~R3, R12}   @再恢复 R0~R3, R12



===================================跳转指令

①、直接使用跳转指令 B、 BL、 BX 等。
②、直接向 PC 寄存器里面写入数据。

上述两种方法都可以完成跳转操作，但是一般常用的还是 B、 BL 或 BX，用法如下：

指令                 描述
B<label>             跳转到 label，如果跳转范围超过了+/-2KB，可以指定 B.W<label>使用 32 位版本的跳转指令， 可以得到较大范围的跳转
BX<Rm>               间接跳转，跳转到存放于 Rm 中的地址处，并且切换指令集
BL<label>            跳转到标号地址，并将返回地址保存在 LR 中。
BLX<Rm>              结合 BX 和 BL 的特点，跳转到 Rm 指定的地址，并将返回地址保存在 LR 中，切换指令集。


B 指令(跳转到指定地址)
这是最简单的跳转指令， B 指令会将 PC 寄存器的值设置为跳转目标地址， 一旦执行 B 指令， ARM 处理器就会立即跳转到指定的目标地址。
如果要调用的函数不会再返回到原来的执行处，那就可以用 B 指令，如下示例：

_start:
ldr sp,=0X80200000       @设置栈指针
b main                   @跳转到 main 函数

上述代码就是典型的在汇编中初始化 C 运行环境，然后跳转到 C 文件的 main 函数中运行
上述代码只是初始化了 SP 指针，有些处理器还需要做其他的初始化，比如初始化 DDR 等等。
因为跳转到 C 文件以后再也不会回到汇编了，所以在第 4 行使用了 B 指令来完成跳转。



BL 指令(在跳转到指定地址之前将值保存在LP寄存器中,后面可以重新加载回来)
BL 指令相比 B 指令，在跳转之前会在寄存器 LR(R14)中保存当前 PC 寄存器值，
所以可以通过将 LR 寄存器中的值重新加载到 PC 中来继续从跳转之前的代码处运行，这是子程序调用一个基本但常用的手段。
比如 Cortex-A 处理器的 irq 中断服务函数都是汇编写的，主要用汇编来实现现场的保护和恢复、获取中断号等。
但是具体的中断处理过程都是 C 函数，所以就会存在汇编中调用 C 函数的问题。
而且当 C 语言版本的中断处理函数执行完成以后是需要返回到irq 汇编中断服务函数，因为还要处理其他的工作，一般是恢复现场。
这个时候就不能直接使用B 指令了，因为 B 指令一旦跳转就再也不会回来了，这个时候要使用 BL 指令，示例代码如下：

BL 指令示例:
push {r0, r1} @保存 r0,r1
cps #0x13 @进入 SVC 模式，允许其他中断再次进去
bl system_irqhandler @加载 C 语言中断处理函数到 r2 寄存器中
cps #0x12 @进入 IRQ 模式
pop {r0, r1}
str r0, [r1, #0X10] @中断执行完成，写 EOIR


===================================算术运算指令

汇编中也可以进行算术运算,如下所示：
指令                      计算公式                       备注
ADD Rd, Rn, Rm            Rd = Rn + Rm                   加法运算，指令为 ADD
ADD Rd, Rn, #immed        Rd = Rn + #immed               加法运算，指令为 ADD
ADC Rd, Rn, Rm            Rd = Rn + Rm + 进位            带进位的加法运算，指令为 ADC
ADC Rd, Rn, #immed        Rd = Rn + #immed +进位         带进位的加法运算，指令为 ADC
SUB Rd, Rn, Rm            Rd = Rn – Rm                  减法
SUB Rd, #immed            Rd = Rd - #immed               减法
SUB Rd, Rn, #immed        Rd = Rn - #immed               减法
SBC Rd, Rn, #immed        Rd = Rn - #immed – 借位       带借位的减法
SBC Rd, Rn ,Rm            Rd = Rn – Rm – 借位          带借位的减法
MUL Rd, Rn, Rm            Rd = Rn * Rm                   乘法(32 位)
UDIV Rd, Rn, Rm           Rd = Rn / Rm                   无符号除法
SDIV Rd, Rn, Rm           Rd = Rn / Rm                   有符号除法



===================================逻辑运算指令

指令                      计算公式                       备注
AND Rd, Rn                Rd = Rd &Rn                    按位与
AND Rd, Rn, #immed        Rd = Rn &#immed                按位与
AND Rd, Rn, Rm            Rd = Rn & Rm                   按位与
ORR Rd, Rn                Rd = Rd | Rn                   按位或
ORR Rd, Rn, #immed        Rd = Rn | #immed               按位或
ORR Rd, Rn, Rm            Rd = Rn | Rm                   按位或
BIC Rd, Rn                Rd = Rd & (~Rn)                位清除
BIC Rd, Rn, #immed        Rd = Rn & (~#immed)            位清除
BIC Rd, Rn , Rm           Rd = Rn & (~Rm)                位清除
ORN Rd, Rn, #immed        Rd = Rn | (#immed)             按位或非
ORN Rd, Rn, Rm            Rd = Rn | (Rm)                 按位或非
EOR Rd, Rn                Rd = Rd ^ Rn                   按位异或
EOR Rd, Rn, #immed        Rd = Rn ^ #immed               按位异或
EOR Rd, Rn, Rm            Rd = Rn ^ Rm                   按位异或