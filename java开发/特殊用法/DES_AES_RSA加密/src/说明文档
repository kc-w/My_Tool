#### 加密方式
1. 对称加密：DES/util (加密和解密所用密钥相同)
2. 非对称：RSA (加密解密所用密钥不同)
#### 密钥的生成方式
1. KeyGenerator和SecretKeyFactory，都是javax.crypto包的，生成的key主要是提供给AES，DES，3DES，MD5，SHA1等**对称** **单向** 加密算法。  
2. KeyPairGenerator和KeyFactory，都是java.security包的，生成的key主要是提供给DSA，RSA， EC等**非对称**加密算法。
3. SecretKeySpec类:同时实现了Key和KeySpec接口,该类可以直接用keyBytes生成原始的key(没有加工过)（若加密方式为DES,则**密钥长度key必须为8位**，其他密钥生成方式无要求）

#### 块加密模式
1. ECB电码本模式：（DES算法默认，不支持IV向量）
2. CBC加密块链模式：（支持IV向量且必须向量）
    在CBC（不光是DES算法）模式下，iv通过随机数（或伪随机）机制产生是一种比较常见的方法。iv的作用主要是用于产生密文的第一个block，以使最终生成的密文产生差异（明文相同的情况下），使密码攻击变得更为困难，除此之外iv并无其它用途。因此iv通过随机方式产生是一种十分简便、有效的途径。此外，在IPsec中采用了DES-CBC作为缺省的加密方式，其使用的iv是通讯包的时间戳。（即使相同的明文，相同的密钥，能产生不同的密文）例如，我们用DES方式在数据保存用户密码的时候，可以另外增加一列，把向量同时保存下来，并且每次用不同的向量。这样的好处是，即使两个用户的密码是一样的，数据库保存的密文，也会不一样，就能降低猜测的可能性。
3. OFB输出反馈模式：（支持IV向量）
4. CFB加密反馈模式：（支持IV向量）  
3DES(DESede) 只支持ECB和CBC两种  
ECB模式简单，缺点是块加密的内容容易重复，会被统计分析攻击；
CBC,  OFB,  CFB三个模式，都是根据前面加密块的内容，对key进行新一轮处理后再，再对下一数据块进行处理，如此类推下去，这样一来，加密的强度也有所增强。他们都需要用到初始化向量IV，英文大概是Initialization Vector的缩写吧。
填充：
对于加密，因为DES是块加密，数据长度必须是8的倍数，然而实际上加密前的明文getBytes()后基本不会恰好是8的倍数，所以一般需要进行填充，填充的规则这里不说，想知道的百度吧，反正这个只需要设置参数 PKCS5Padding ，JDK就帮你填充了，若不填充，且数据长度不是8倍数，则会抛异常；
对于解密，一般来说加密的数据长度本身就是8的倍数，所以只需要NoPadding就可以了，若加密的数据长度不是8，就需要用PKCS5Padding，否则解密出来后的明文尾巴的会比原明文的尾巴多出好几位填充数据。（实测其它模式是，会抛 Given final block not properly padded的异常，这个要结合实际切换一下NoPadding 和 PKCS5Padding）

####RSA
当加密的数据太长的时候则需要分组加密，不然数据过长会抛异常，如“Encryt data is too much”，或者“data length is longer than 127”等。
上面三个方法使用的key的n值（modulus）是1024bit的，也就是128byte，根据RSA加密规则，加密1 byte字节的数据，需要12 byte，即其他11byte可能用于记录其他信息什么的，这里我就不清楚了，而1024bit长度的key则最多可以加密128-11=117byte的数据，所以，对于超过117byte的数据，我们需要以117byte为一组进行数据分割。