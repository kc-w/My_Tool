有些信息在存储时，并不需要占用一个完整的字节，而只需占几个或一个二进制位。
位域在本质上就是一种结构类型，不过其成员是按二进位分配的。
为了节省存储空间，并使处理简便，C 语言又提供了一种数据结构，称为"位域"或"位段"。

===位域的定义和位域变量的说明
struct 位域结构名 {
 类型说明符 位域名: 位域长度
 ...
};

//说明 data 为 bs 变量，共占两个字节。其中位域 a 占 8 位，位域 b 占 2 位，位域 c 占 6 位。
struct bs{
    int a:8;
    int b:2;
    int c:6;
}data;

//packed_struct 包含了 6 个成员：四个 1 位的标识符 f1..f4、一个 4 位的 type 和一个 9 位的 my_int。
struct packed_struct {
  unsigned int f1:1;
  unsigned int f2:1;
  unsigned int f3:1;
  unsigned int f4:1;
  unsigned int type:4;
  unsigned int my_int:9;
} pack;


一个位域存储在同一个字节中，如一个字节所剩空间不够存放另一位域时，则会从下一单元起存放该位域。
也可以有意使某位域从下一单元开始。例如：

//在这个位域定义中，a 占第一字节的 4 位，后 4 位填 0 表示不使用，b 从第二字节开始，占用 4 位，c 占用 4 位。
//位域不允许跨两个字节，位域的长度不能超过8位二进位。
//如果最大长度大于计算机的整数字长，一些编译器会允许域的内存重叠，另外一些编译器会把大于一个域的部分存储在下一个字节中。
//位域可以是无名位域，这时它只用来作填充或调整位置。无名的位域是不能使用的。例如：
struct bs{
    int a:4;
    int  :4;    /* 空域,不能使用 */
    int b:4;    /* 从下一单元开始存放 */
    int c:4
}

main(){
    struct bs{
        unsigned a:1;//取值范围为0-1
        unsigned b:3;//取值范围为0-7
        unsigned c:4;//取值范围为0-15
    } bit,*pbit;
    bit.a=1;    /* 给位域赋值（应注意赋值不能超过该位域的允许范围） */
    bit.b=7;    /* 给位域赋值（应注意赋值不能超过该位域的允许范围） */
    bit.c=15;    /* 给位域赋值（应注意赋值不能超过该位域的允许范围） */
    printf("%d,%d,%d\n",bit.a,bit.b,bit.c);    /* 以整型量格式输出三个域的内容 */
    pbit=&bit;    /* 把位域变量 bit 的地址送给指针变量 pbit */
    pbit->a=0;    /* 用指针方式给位域 a 重新赋值，赋为 0 */
    pbit->b&=3;    /* 使用了复合的位运算符 "&="，相当于：pbit->b=pbit->b&3，位域 b 中原有值为 7，与 3 作按位与运算的结果为 3（111&011=011，十进制值为 3） */
    pbit->c|=1;    /* 使用了复合位运算符"|="，相当于：pbit->c=pbit->c|1，其结果为 15 */
    printf("%d,%d,%d\n",pbit->a,pbit->b,pbit->c);    /* 用指针方式输出了这三个域的值 */
}

位域大小(字节递增以数组类型最大的为标准,以下以int为例,如果总大小超过4字节则加4字节按8字节算,不同数据类型可连续排放)
struct packed_struct {
    int a:8;
    int b:2;
    short c:15;
};
